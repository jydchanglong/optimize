# HTTP

尽可能让浏览器使用缓存资源，同时保证缓存的资源和服务端最新的资源保持一致

### 强制缓存

浏览器**先从缓存**中查找资源，如果没有则向服务器发请求

1. HTTP/1.0 通过在响应头部设置 **Expires** 来设置缓存时间

   - 服务端和客户端时间容易出现偏差
   - 客户端也可以修改修改系统时间让缓存失效

2. HTTP/1.1 提出了 **Cache-Control** 响应头部字段，它的常用值：

   - no-cache：表示使用协商缓存
   - no-store：表示禁止缓存响应内容
   - public：共有缓存，可以被代理服务器缓存
   - private：私有缓存，不可以被代理服务器缓存
   - max-age：表示缓存有效时间，单位是秒
   - must-revalidate：当缓存过期，需要去服务端校验缓存有效性

   这几个值可以组合使用，用逗号间隔

   tips：

   - max-age 的优先级要**高于** Expires

   - 尽量**不要**使用 meta 标签来设置缓存，因为 HTML5 规范不支持

     ```html
     <meta http-equiv="expires" content="Wed, 20 Jun 2021 22:33:00 GMT" />
     ```

     

### 协商缓存

浏览器向服务端发送请求，由服务端确认缓存是否有效。如果请求响应返回的状态码是 304 ，则表示缓存有效。

- #### Last-Modified 与 If-Modified-Since

  1. 浏览器首次向服务端发请求，服务端在响应头添加 Last-Modified 字段，其值为请求资源在服务端上最近一次的修改时间
  2. 浏览器第二次发出请求，通过请求头的 If-Modified-Since 字段把之前的时间发给服务端
  3. 服务端根据 If-Modified-Since 的值判断资源是否有更新，如果没有就返回 304 ，如果有就返回新资源
  4. 存在的问题：
     - 精度问题：如果在 1 秒内发生修改，那么缓存判断可能会失效
     - 准度问题：如果一个文件并没有实质性修改，但修改时间发生了变化，那么也会返回新资源

- #### ETag 和 If-None-Match

  

- 

  

  

  #### 

  

  

  

# ServiceWorker