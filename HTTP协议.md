## HTTP/0.9

传输超文本内容 HTML，1991 年诞生

协议定义了由客户端发起一个请求，服务端响应请求的通信模式

请求报文内容为一行 GET请求 + 文件路径（GET/index.html），服务端返回 ASCII 字符流编码的HTML 文档

## HTTP/1.0

传输脚本、样式、图片、音频、视频等不同类型的文件，1996 年诞生

核心改变是增加了**头部设定**，请求头部通过 accept 字段通知服务端可以接收的文件类型（accept:text/css），响应头通过 Content-type 字段通知浏览器返回的文件类型（Content-type: text/css）

## HTTP/1.1

HTTP/1.0 每次通信都会经历建立连接、传输数据、断开连接这三个步骤，当传输多个文件时会造成大量网络开销。所以 1.1 增加了一个创建**持久连接**的方法，当一个连接传输完成时可以继续复用传输其他文件。1999 年诞生

## HTTP/2

- 浏览器限制了同一域下 HTTP 连接的数量（6~8个），所以在 1.1  下容易看到资源等待加载的情况。对应优化方法是：使用多个域名来加载图片资源。
- 1.1 下会出现“**队头阻塞**”的问题，即在一个连接中同一时刻只能处理一个请求，其他请求只能处于阻塞状态。

在 2015 年发布的 2 中，新增了一个**二进制分帧**的机制来提升传输效率

1. HTTP/2 默认使用二进制数据传输。客户端发送请求时会将每个请求封装成带有不同编号的二进制帧，然后把这些帧同时发给服务端。
2. 服务端接收后，通过编码把二进制帧合并为完整的请求信息。
3. 同理客户端也遵循这个拆分组合的过程。把这种方式称为**多路复用**

HTTP/2 还包括：压缩头部信息减少传输体积、通过服务推送减少客户端请求。

参考连接：https://www.jianshu.com/p/e57ca4fec26f

## HTTP/3

HTTP/2 在丢包或网络中断时，后面的数据都会被阻塞。

2018 年 HTTP/3 将底层依赖的 TCP 改成 UDP。UDP 传输数据时不需要建立连接而且可以同时发送多个数据包，效率很高，但是它没有确认机制保证对方一定能收到数据。

参考连接：https://quic-lr-draft-zh.readthedocs.io/zh_CN/latest/An%20Overview%20of%20QUIC%20Loss%20Recovery.html



| 版本 | 解决问题               | 解决方式                                       |
| ---- | ---------------------- | ---------------------------------------------- |
| 0.9  | 传输HTML文本内容       | 确立了客户端发送请求，服务端响应请求的通信模式 |
| 1.0  | 传输不同类型的文件     | 添加请求头部和响应头部                         |
| 1.1  | 连接/断开 TCP 性能损耗 | 建立了长连接                                   |
| 2    | 请求数量限制           | 二进制分帧，多路复用                           |
| 3    | 丢包阻塞               | 底层改用 UDP 协议                              |



## Tips

#### 1、TCP 建立或断开连接

- ##### 三次握手

  1. 起初客户端处于 CLOSED 状态，服务端处于 LISTEN 状态。客户端给服务端发送 SYN 报文，并指明客户端的初始序列号 ISN。此时客户端处于 SYN_SEND 状态。
  2. 服务端收到报文后，会发送自己的 SYN 报文，并也指明自己的 ISN 。同时把客户端的 ISN + 1 作为 ACK 的值。此时服务端处于 SYN_SEND 状态。
  3. 客户端收到报文后，会发送一个 ACK 报文，并把服务端的 ISN + 1 作为 ACK 的值，此时客户端处于 ESTABLISHED 状态。服务端收到 ACK 报文后，也处于 ESTABLISHED 状态。双方成功建立起了连接。

- ##### 四次挥手

  1. 此时客户端和服务端都处于 ESTABLISHED 状态。客户端发送一个 FIN 报文给服务端，此时客户端处于 FIN_WAIT_1 状态。
  2. 服务端收到报文后，会发送 ACK 报文给客户端，同时把客户端的序列号值 + 1 作为 ACK 的序列号值，此时服务端处于 CLOSE_WAIT。
  3. 如果服务端同意关闭连接，会发送 FIN 报文给客户端并指定一个序列号，此时服务端处于 LAST_ACK 状态。
  4. 客户端收到 ACK 报文后处于 FIN_WAIT_2 状态。当客户端收到 FIN 报文后，会发送一个 ACK 报文给服务端并把服务端的序列号 + 1 作为 ACK 的序列号值，此时客户端处于 CLOSED 状态。当服务端收到 ACK 报文后也会处于 CLOSED 状态。此时连接正式断开

- 为什么建立连接只通信了三次，而断开连接却用了四次？

  因为当服务端收到客户端的 FIN 报文后，发送的 ACK 报文只是用来应答的，并不表示服务端也希望立即关闭连接。

  当只有服务端把所有的报文都发送完了，才会发送 FIN 报文，告诉客户端可以断开连接了，因此在断开连接时需要四次挥手。

#### 2、HTTPS 原理

- 对称加密

  在加密/解密的过程中使用同一密钥。

- 非对称加密

  由于不可能保证客户端和服务端同时生成一个相同的随机密钥，所以需要通过将密钥加密来进行传输。

  客户端通过公钥加密，服务端通过私钥解密

- 证书机制

  服务端生成密钥对，把公钥放入一个证书中（它里面包含服务端的信息），需要 CA 认证中心对证书进行签名。

  - 证书签名过程：将证书信息进行 MD5 计算，然后利用证书颁发方的私钥对其进行加密。
  - 证书校验过程：利用证书颁发方的公钥进行解密，然后计算证书信息的 MD5 值，将解密后的 MD5 和上面的 MD5 对比。
  - 证书颁发方的公钥就在证书中



